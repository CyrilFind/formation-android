
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TP 3: L&#39;Internet</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="TP3"
                  title="TP 3: L&#39;Internet"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Mise en place" duration="0">
        <p>L&#39;API de Todoist n√©cessite qu&#39;une personne soit connect√©e, pour commencer nous allons simuler cela en passant directement un <code>token</code> dans les <code>headers</code> de nos requ√™tes <code>HTTP</code>:</p>
<ul>
<li>Rendez vous sur <a href="https://todoist.com/app" target="_blank">todoist.com</a></li>
<li>Cr√©ez un compte, allez dans <code>Param√®tres > Int√©grations > Cl√© API</code> et copiez la quelque part</li>
<li>lisez un peu <a href="https://developer.todoist.com" target="_blank">la doc de l&#39;API</a>, il y en a en fait 2: REST (ex: <a href="https://developer.todoist.com/rest/v2/#tasks" target="_blank">tasks</a>) et Sync (ex: <a href="https://developer.todoist.com/sync/v9/#user" target="_blank">user</a>)</li>
<li>En utilisant la cl√© copi√©e et les exemples de la documentation testez de cr√©er un tache avec <code>curl</code> (ou Postman, <a href="https://httpie.io/" target="_blank">httpie</a>, ...)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Acc√©der √† l&#39;internet" duration="0">
        <p>Afin de communiquer avec le r√©seau internet (wifi, ethernet ou mobile), il faut ajouter la permission dans le fichier <code>AndroidManifest</code>, juste au dessus de la balise <code>application</code></p>
<pre><code language="language-xml" class="language-xml">&lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&gt;
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ C&#39;est ici une &#34;install-time permission&#34;, car elle n&#39;est pas critique, et donc il n&#39;y a pas besoin de la demander explicitement √† l&#39;utilisateur, elle est accept√©e √† l&#39;installation.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout des d√©pendances" duration="0">
        <p>Dans le fichier <code>app/build.gradle.kts</code> (celui du module):</p>
<ul>
<li>Dans <code>dependencies {}</code>, ajouter les d√©pendances qui vous manquent (mettre les versions plus r√©centes si l&#39;IDE vous le propose, il vous permet √©galement de facilement les passer dans le <code>libs.versions.toml</code>):</li>
</ul>
<pre><code language="language-groovy" class="language-groovy">// Retrofit
implementation(&#34;com.squareup.retrofit2:retrofit:2.11.0&#34;)
implementation(&#34;com.squareup.okhttp3:logging-interceptor:4.12.0&#34;)

// KotlinX Serialization
implementation(&#34;org.jetbrains.kotlin:kotlinx-serialization-json:1.6.2&#34;)
implementation(&#34;com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0&#34;)

// Coroutines
implementation(&#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&#34;)
implementation(&#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&#34;)
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ les <code>implementation()</code> listent les d√©pendances du module li√© au fichier gradle en question (ici <code>app</code>, notre unique module)</p>
<p>Afin de centraliser la liste des d√©pendances utilis√©es dans tout le projet, et √©viter d&#39;avoir des versions diff√©rentes, on recommande d&#39;utiliser <code>libs.versions.toml</code> qui liste ces infos et les rends accessibles ensuite dans tous les modules:</p>
<pre><code language="language-toml" class="language-toml">[versions]
# ...
retrofit = &#34;3.0.0&#34;
# ...

[libraries]
# ...
retrofit = &#34;3.0.0&#34;
# ...
square-retrofit = { module = &#34;com.squareup.retrofit2:retrofit&#34;, version.ref = &#34;retrofit&#34; }
# ...

[plugins]
# ...
kotlin-android = { id = &#34;org.jetbrains.kotlin.android&#34;, version.ref = &#34;kotlin&#34; }
# ...
</code></pre>
<p>Ensuite √ßa s&#39;utilise comme ceci:</p>
<pre><code language="language-gradle" class="language-gradle">// `libs.&lt;nom en rempla√ßant les &#39;-&#39; par des &#39;.&#39;&gt;`
dependencies {
  implementation(libs.square.retrofit)
}

// pour les plugins, c&#39;est avec `alias` et `libs.plugins...`:
plugins {
  alias(libs.plugins.kotlin.android)
}
</code></pre>
</aside>
<ul>
<li>Tout en haut ajoutez le plugin de s√©rialisation:</li>
</ul>
<pre><code language="language-groovy" class="language-groovy">plugins {
    id(&#34;org.jetbrains.kotlin.plugin.serialization&#34;) version &#34;2.0.0&#34;
}
</code></pre>
<ul>
<li>Apr√®s tout cela vous pouvez cliquer sur &#34;Sync Now&#34; pour que l&#39;IDE t√©l√©charge les d√©pendances, etc.</li>
<li>Passez toutes ces d√©pendances dans libs.versions.toml en vous aidant de l&#39;IDE</li>
<li>Faites pareil pour le plugin, en utilisant <code>version.ref = "kotlin"</code></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Retrofit" duration="0">
        <ul>
<li>Cr√©ez un package <code>data</code></li>
<li>Cr√©ez y un <code>object Api</code> (ses membres et m√©thodes seront donc <code>static</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object Api {
  private const val TOKEN = &#34;COPIEZ_VOTRE_CLE_API_ICI&#34;

  private val retrofit by lazy {
    // client HTTP
    val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY))
        .addInterceptor { chain -&gt;
          // intercepteur qui ajoute le `header` d&#39;authentification avec votre token:
          val newRequest = chain.request().newBuilder()
            .addHeader(&#34;Authorization&#34;, &#34;Bearer $TOKEN&#34;)
            .build()
          chain.proceed(newRequest)
        }
        .build()

    // transforme le JSON en objets kotlin et inversement
    val jsonSerializer = Json {
        ignoreUnknownKeys = true
        coerceInputValues = true
        encodeDefaults = true
    }

    // instance retrofit pour impl√©menter les webServices:
    Retrofit.Builder()
      .baseUrl(&#34;https://api.todoist.com/&#34;)
      .client(okHttpClient)
      .addConverterFactory(jsonSerializer.asConverterFactory(&#34;application/json&#34;.toMediaType()))
      .build()
    }
}
</code></pre>
<aside class="special"><p>Ici je vous donne tout ce code de config car ce n&#39;est pas tr√®s int√©ressant √† chercher mais prenez quelques minutes pour lire et comprendre ce qu&#39;il fait avant de copier-coller:</p>
<ul>
<li>on cr√©e un client HTTP (avec <a href="https://square.github.io/okhttp/" target="_blank">OkHttp</a>)</li>
<li>on cr√©e un JSON serializer (avec <a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank">KotlinX Serialization</a>)</li>
<li>on cr√©e une instance de <a href="https://square.github.io/retrofit/" target="_blank">Retrofit</a> que l&#39;on configure avec les √©l√©ments ci dessus (en adaptant le Serializer en <code>ConverterFactory</code>)</li>
</ul>
</aside>
<aside class="warning"><p>la syntaxe <code>val retrofit by lazy { ... }</code> permet d&#39;initialiser la variable <code>retrofit</code> automatiquement la premi√®re fois qu&#39;elle sera utilis√©e</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="User" duration="0">
        <p>Extrait d&#39;un json renvoy√© par la route <code>/sync/v9/user/</code>:</p>
<pre><code language="language-json" class="language-json">{
  &#34;email&#34;: &#34;example@domain.com&#34;,
  &#34;full_name&#34;: &#34;john doe&#34;,
  &#34;avatar_medium&#34;: &#34;https://blablabla/image.jpg&#34;
}
</code></pre>
<p>Cr√©er la <code>data class User</code> correspondante:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Serializable
data class User(
  @SerialName(&#34;email&#34;)
  val email: String,
  @SerialName(&#34;full_name&#34;)
  val name: String,
  @SerialName(&#34;avatar_medium&#34;)
  val avatar: String? = null
)
</code></pre>
<aside class="special"><p>Regardez bien les annotations ici (tout ce qui commence par <code>@</code>): elle servent √† la lib <code>KotlinX Serialization</code> pour d√©limiter les √©l√©ments √† parser et comment, avec les cl√©s pass√©es en argument</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="UserWebService" duration="0">
        <ul>
<li>Cr√©ez l&#39;interface <code>UserWebService</code> pour requ√™ter les infos de l&#39;utilisateur (importez <code>Response</code> avec <code>alt + enter</code> et choisissez la version <code>retrofit</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">interface UserWebService {
  @GET(&#34;/sync/v9/user/&#34;)
  suspend fun fetchUser(): Response&lt;User&gt;
}
</code></pre>
<aside class="special"><p><code>Response</code> est un type qui &#34;encapsule&#34; une r√©ponse HTTP: on peut y retrouver un code de r√©ponse, un message d&#39;erreur, etc... et un r√©sultat: ici une instance de <code>User</code></p>
</aside>
<ul>
<li>Utilisez retrofit pour cr√©er une impl√©mentation de ce service:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object Api {
  val userWebService : UserWebService by lazy {
    retrofit.create(UserWebService::class.java)
  }
}
</code></pre>
<aside class="special"><p>Ici, Retrofit va cr√©er une impl√©mentation de l&#39;interface <code>UserWebService</code> pour nous, en utilisant d&#39;une part les valeurs de base configur√©es dans <code>Api</code> et d&#39;autre part les annotations (<code>@</code>) qui lui donnent le type de requ√™te (ex: <code>GET</code>), la route, les types de param√®tres, etc.</p>
<p>Utiliser des interfaces est souvent pr√©f√©rables pour pouvoir interchanger facilement les impl√©mentations: par exemple si on change une source de donn√©es, une d√©pendances, etc..</p>
<p>Typiquement dans les Tests Unitaires, on a souvent une &#34;fausse impl√©mentation&#34; qui ne fait pas vraiment de requ√™tes mais retourne des r√©ponses fixes directement</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Affichage" duration="0">
        <ul>
<li>Dans votre Activity, ajoutez un composant <code>Text</code> pour voir les r√©sultats de l&#39;API:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">// Ici on ne va pas g√©rer les cas d&#39;erreur donc on force le crash avec &#34;!!&#34;
val user = Api.userWebService.fetchUser().body()!!
</code></pre>
<ul>
<li>Afficher votre nom d&#39;utilisateur dans le <code>Text</code></li>
</ul>
<p>‚û°Ô∏è Lancez l&#39;app et v√©rifiez que vos infos s&#39;affichent !</p>
<aside class="warning"><p>‚ö†Ô∏è Sur √©mulateur, √† cette √©tape il y a parfois des crashs √©tranges:</p>
<ul>
<li>&#34;<code>...EPERM (operation not permitted)...</code>&#34;: d√©sinstallez l&#39;application de l&#39;√©mulateur et relancez</li>
<li>L&#39;app stoppe direct et sans stacktrace: red√©marrer l&#39;√©mulateur et v√©rifiez que son wifi est bien connect√©</li>
</ul>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="API REST" duration="0">
        <p>Il est temps de r√©cup√©rer les t√¢ches depuis le serveur !</p>
<p>Cr√©er un nouveau service <code>TaskWebService</code>:</p>
<pre><code language="language-kotlin" class="language-kotlin">interface TasksWebService {
  @GET(&#34;/rest/v2/tasks/&#34;)
  suspend fun fetchTasks(): Response&lt;List&lt;Task&gt;&gt;
}
</code></pre>
<ul>
<li>Utiliser l&#39;instance de retrofit comme pr√©c√©demment pour cr√©er une instance de <code>TasksWebService</code> dans l&#39;objet <code>Api</code></li>
</ul>
<p>Extrait d&#39;un json renvoy√© par la route <code>/rest/v2/tasks/</code>:</p>
<pre><code language="language-json" class="language-json">[
  {
    &#34;content&#34;: &#34;title&#34;,
    &#34;description&#34;: &#34;description&#34;,
    &#34;id&#34;: &#34;123456789&#34;
  }
]
</code></pre>
<ul>
<li>Modifier <code>Task</code> pour la rendre &#34;serializable&#34; par KotlinX Serialization (inspirez vous de <code>User</code>)</li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è Ici vous aurez peut √™tre un conflit d&#39;imports car on a pr√©c√©demment fait h√©riter <code>Task</code> de <code>Serializable</code>, et une des annotations de KotlinX Serialization s&#39;appelle aussi <code>@Serializable</code>: faites h√©riter explicitement de <code>java.io.Serializable</code> pour lever l&#39;ambigu√Øt√©.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListViewModel" duration="0">
        <aside class="special"><p>üßë‚Äçüè´ <code>ViewModel</code> est une classe du framework Android qui permet de g√©rer les donn√©es d&#39;une vue, et dont on peut facilement cr√©er et r√©cup√©rer une instance, en g√©n√©ral chacune associ√©e √† une <code>Activity</code>, un <code>Fragment</code>, ou une <code>NavEntry</code></p>
<p>On va donc y d√©placer une partie de la logique: dans l&#39;id√©al l&#39;<code>Activity</code> ou le <code>Fragment</code> doit seulement s&#39;occuper de passer les √©v√®nements (comme les clics) au VM, et ins√©rer ce que le VM lui dit d&#39;afficher dans les vues</p>
</aside>
<p>Cr√©er la classe <code>TaskListViewModel</code>, avec une liste de t√¢ches <em>Observable</em> gr√¢ce au <code>MutableStateFlow</code>:</p>
<pre><code language="language-kotlin" class="language-kotlin">class TaskListViewModel : ViewModel() {
  private val webService = Api.tasksWebService

  public val tasksStateFlow = MutableStateFlow&lt;List&lt;Task&gt;&gt;(emptyList())

  init {
    refresh()
  }

  fun refresh() {
      viewModelScope.launch {
          val response = webService.fetchTasks() // Call HTTP (op√©ration longue)
          if (!response.isSuccessful) { // √† cette ligne, on a re√ßu la r√©ponse de l&#39;API
            Log.e(&#34;Network&#34;, &#34;Error: ${response.message()}&#34;)
            return@launch
          }
          val fetchedTasks = response.body()!!
          tasksStateFlow.value = fetchedTasks // on modifie le flow, ce qui d√©clenche ses observers
      }
  }

  // √† compl√©ter plus tard:
  fun add(task: Task) {}
  fun edit(task: Task) {}
  fun remove(task: Task) {}
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="&#34;Collecter&#34; le Flow" duration="0">
        <ul>
<li>Dans <code>ListScreen</code>, ajouter en a une argument une instance de <code>TaskListViewModel</code></li>
<li>Dans <code>NavDisplay</code>, ajoutez des <code>entryDecorators</code> qui vont permettre aux ViewModels de correspondre aux <code>NavEntry</code> et cr√©ez un ViewModel √† passer √† <code>ListScreen</code> avec <code>viewModel { }</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">NavDisplay(
    //...
    entryDecorators = listOf(
        rememberSaveableStateHolderNavEntryDecorator(),
        rememberViewModelStoreNavEntryDecorator()
    ),
    // ...
    entryProvider = entryProvider {
        entry&lt;ListNavScreen&gt; {
            ListScreen(
              viewModel = viewModel { TaskListViewModel(it.task) }
              // ...
            )
        }
        // ...
    }
)

fun ListScreen(
  modifier: Modifier = Modifier,
  viewModel: TaskListViewModel,
) {
  val state by viewModel.tasksStateFlow.collectAsStateWithLifecycle()
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Compl√©ter TasksWebService" duration="0">
        <p>Modifier <code>TasksWebService</code> et ajoutez y les routes manquantes:</p>
<pre><code language="language-kotlin" class="language-kotlin">@POST(&#34;/rest/v2/tasks/&#34;)
suspend fun create(@Body task: Task): Response&lt;Task&gt;

@POST(&#34;/rest/v2/tasks/{id}&#34;)
suspend fun update(@Body task: Task, @Path(&#34;id&#34;) id: String = task.id): Response&lt;Task&gt;

// Compl√©tez avec les m√©thodes pr√©c√©dentes, la doc de l&#39;API, et celle de Retrofit:
@...
suspend fun delete(@... id: String): Response&lt;Unit&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Suppression, Ajout, √âdition" duration="0">
        <ul>
<li>Inspirez vous du fonctionnement de <code>refresh()</code> pour ajouter toutes les autres actions avec le serveur dans le VM, par ex pour l&#39;√©dition:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">fun update(task: Task) {
  viewModelScope.launch {
    val response = ... // TODO: appel r√©seau
    if (!response.isSuccessful) {
      Log.e(&#34;Network&#34;, &#34;Error: ${response.raw()}&#34;)
      return@launch
    }

    val updatedTask = response.body()!!
    val updatedList = tasksStateFlow.value.map {
      if (it.id == updatedTask.id) updatedTask else it
    }
    tasksStateFlow.value = updatedList
  }
}
</code></pre>
<ul>
<li>Supprimez la <code>taskList</code> locale dans l&#39;√©cran de la Liste et v√©rifier que vous avez bien tout remplac√© par des appels au VM (et donc au serveur), il ne doit rester plus qu&#39;un seul endroit o√π vous mettez √† jour l&#39;adapter: dans le <code>.collect { }</code></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="States" duration="0">
        <p>On va ajouter un √©tat d&#39;erreur avec une <code>sealed class</code> Dans <code>TaskListViewModel</code>, ajoutez la classe suivante:</p>
<pre><code language="language-kotlin" class="language-kotlin">sealed class TaskListState {
  data object Loading : TaskListState()
  data class Success(val list: List&lt;Task&gt;) : TaskListState()
  data class Error(val message: String) : TaskListState()
}
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ une <strong>sealed class</strong> est une classe qui peut √™tre <strong>h√©rit√©e</strong> (ce n&#39;est pas le cas par d√©faut en kotlin), mais la subtilit√© est que ses <strong>classes filles</strong> sont connues √† la compilation, et il ne peut pas y en avoir d&#39;autres, ce qui permet de simplifier certaines informations: par exemple ici on sait que notre √©cran sera  dans l&#39;√©tat: SOIT &#34;affiche une liste&#34; SOIT dans l&#39;√©tat &#34;erreur avec un message&#34; SOIT &#34;en train de charger&#34;, il n&#39;y a pas d&#39;autres possiblit√©s</p>
<p>C&#39;est un peu comme un enum mais avec une classe compl√®te.</p>
<p>Les <code>enum class</code> existent √©galement mais mais les diff√©rentes <strong>instances</strong> sont connues √† la compilation, par exemple:</p>
<pre><code language="language-kotlin" class="language-kotlin">enum class Event(val name) {
    CREATE(&#34;create&#34;)
    DELETE(&#34;delete&#34;)
    //...
}
</code></pre>
</aside>
<ul>
<li>Changez <code>tasksStateFlow</code> pour qu&#39;il contienne un <code>TaskListState</code> et pas une liste directement, avec <code>Loading</code> comme valeur initiale</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">public val tasksStateFlow = MutableStateFlow&lt;TaskListState&gt;(TaskListState.Loading)
</code></pre>
<ul>
<li>Dans votre composant <code>ListScreen</code>, utilisez un <code>when</code> pour afficher les diff√©rents √©tats:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">when (val currentState = state.value) {
  is TaskListState.Loading -&gt; CircularProgressIndicator()
  is TaskListState.Error -&gt; Text(text = currentState.message)
  is TaskListState.Success -&gt; { /* votre liste pr√©c√©dente  */ }
</code></pre>
<ul>
<li>Testez et peaufinez un peu l&#39;affichage</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Architecture" duration="0">
        <p>Toute la logique √©tant extraite dans le ViewModel, elle peut √™tre partag√©e avec l&#39;ancien √©cran listant les t√¢ches puisque qu&#39;il fait la m√™me chose.</p>
<p>Adaptez donc tout √ßa dans <code>TaskListFragment</code> en utilisant le m√™me ViewModel, indices pour commencer:</p>
<pre><code language="language-kotlin" class="language-kotlin">private val viewModel: TaskListViewModel by viewModels()

// Dans onResume()
viewModel.refresh() // on demande de rafra√Æchir les donn√©es sans attendre le retour directement

// Dans onViewCreated()
lifecycleScope.launch { // on lance une coroutine car `collect` est `suspend`
    viewModel.tasksStateFlow.collect { newList -&gt;
      // cette lambda est ex√©cut√©e √† chaque fois que la liste est mise √† jour dans le VM
      // -&gt; ici, on met √† jour la liste dans l&#39;adapter
    }
}
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById("arrow-back").href="/formation-android/codelabs/";
            document.getElementById("done").href="/formation-android/codelabs/";
        }, false);
    </script>

    