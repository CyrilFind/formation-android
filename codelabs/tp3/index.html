
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TP 3: L&#39;Internet</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="tp3"
                  title="TP 3: L&#39;Internet"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Avant de commencer" duration="0">
        <p>Les APIs qui nous allons utiliser exigent qu&#39;une personne soit connect√©e, pour commencer nous allons simuler cela en passant directement un <code>token</code> dans les <code>headers</code> de nos requ√™tes <code>HTTP</code>:</p>
<ul>
<li>Rendez vous sur <a href="https://android-tasks-api.herokuapp.com/api-docs/" target="_blank">https://android-tasks-api.herokuapp.com/api-docs/</a></li>
<li>Ce site permet de lire la documentation et d&#39;utiliser les routes directement</li>
<li>Cliquez sur <code>users/sign_up</code> puis sur &#34;Try it out&#34;</li>
<li>Vous devriez voir un JSON pr√©rempli dont vous devez remplir les donn√©es (vous pouvez mettre des infos bidon) avant de cliquer sur &#34;Execute&#34;:</li>
</ul>
<pre><code language="language-json" class="language-json">{
  &#34;firstname&#34;: &#34;UN PRENOM&#34;,
  &#34;lastname&#34;: &#34;UN NOM&#34;,
  &#34;email&#34;: &#34;UN EMAIL&#34;,
  &#34;password&#34;: &#34;UN MDP&#34;,
  &#34;password_confirmation&#34;: &#34;LE MEME MDP&#34;
}
</code></pre>
<ul>
<li>Copiez le token g√©n√©r√© quelque part (vous pourrez le r√©cup√©rer √† nouveau en utilisant la route <code>/login</code>)</li>
<li>Copiez votre token dans la popup du bouton &#34;Authorize&#34; en haut</li>
<li>Maintenant que vous √™tes &#34;logg√©&#34;, testez les routes disponibles (cr√©ation, suppression, etc...)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Acc√©der √† l&#39;internet" duration="0">
        <p>Afin de communiquer avec le r√©seau internet (wifi, ethernet ou mobile), il faut ajouter la permission dans le fichier <code>AndroidManifest</code>, juste apr√®s la balise <code><manifest...></code></p>
<pre><code language="language-xml" class="language-xml">&lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout des d√©pendances" duration="0">
        <p>Dans le fichier <code>app/build.gradle</code>:</p>
<ul>
<li>Dans <code>dependencies {...}</code>, ajouter les d√©pendances qui vous manquent (mettre les versions plus r√©centes si l&#39;IDE vous le propose):</li>
</ul>
<pre><code language="language-groovy" class="language-groovy">    //  Android - KTX
    implementation &#39;androidx.preference:preference-ktx:1.1.1&#39;
    implementation &#39;androidx.activity:activity-ktx:1.3.0-alpha06&#39;
    implementation &#39;androidx.fragment:fragment-ktx:1.3.2&#39;
    implementation &#39;androidx.core:core-ktx:1.3.2&#39;

    // Retrofit
    implementation &#39;com.squareup.retrofit2:retrofit:2.9.0&#39;
    implementation &#39;com.squareup.okhttp3:logging-interceptor:5.0.0-alpha.2&#39;

    // KotlinX Serialization
    implementation &#34;org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0&#34;
    implementation &#39;com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:0.8.0&#39;

    // Coroutines
    implementation &#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3&#34;
    implementation &#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3&#34;

    // Lifecycle
    implementation &#34;androidx.lifecycle:lifecycle-extensions:2.2.0&#34;
    implementation &#34;androidx.lifecycle:lifecycle-runtime-ktx:2.3.1&#34;
    implementation &#34;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&#34;
</code></pre>
<ul>
<li>Dans <code>android {...}</code>:</li>
</ul>
<pre><code language="language-groovy" class="language-groovy">compileOptions {
  sourceCompatibility JavaVersion.VERSION_1_8
  targetCompatibility JavaVersion.VERSION_1_8
}

kotlinOptions {
  jvmTarget = JavaVersion.VERSION_1_8.toString()
}
</code></pre>
<ul>
<li>Tout en haut ajoutez le plugin de s√©rialisation:</li>
</ul>
<pre><code language="language-groovy" class="language-groovy">plugins {
    // ...
    id &#39;org.jetbrains.kotlin.plugin.serialization&#39; version &#34;$kotlin_version&#34;
}
</code></pre>
<p>Apr√®s tout cela vous pouvez cliquer sur &#34;Sync Now&#34; pour que l&#39;IDE synchronise le projet.</p>
<p>En cas de soucis √† ce moment l√†, v√©rifiez que:</p>
<ul>
<li>Android Studio est √† jour (&#34;Check for updates&#34;)</li>
<li>Le Plugin Kotlin est √† jour (<code>Settings > Plugins > Installed > Kotlin</code>)</li>
<li>votre <code>kotlin_version</code> est r√©cente (en haut de <code><PROJECT>/build.gradle</code>, √† l&#39;heure o√π j&#39;√©cris c&#39;est <code>1.4.30</code>)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Retrofit" duration="0">
        <ul>
<li>Cr√©er un package <code>network</code> qui contiendra les classes en rapport avec les √©changes r√©seaux</li>
<li>Cr√©er un <code>object Api</code> (ses membres et m√©thodes seront donc <code>static</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object Api {

  // constantes qui serviront √† faire les requ√™tes
  private const val BASE_URL = &#34;https://android-tasks-api.herokuapp.com/api/&#34;
  private const val TOKEN = &#34;COPIEZ_VOTRE_TOKEN_ICI&#34;

  // client HTTP
  private val okHttpClient by lazy {
    OkHttpClient.Builder()
      .addInterceptor { chain -&gt;
        // intercepteur qui ajoute le `header` d&#39;authentification avec votre token:
        val newRequest = chain.request().newBuilder()
          .addHeader(&#34;Authorization&#34;, &#34;Bearer $TOKEN&#34;)
          .build()
        chain.proceed(newRequest)
      }
      .build()
  }

  // s√©rializeur JSON: transforme le JSON en objets kotlin et inversement
  private val jsonSerializer = Json {
      ignoreUnknownKeys = true
      coerceInputValues = true
  }

  // instance de convertisseur qui parse le JSON renvoy√© par le serveur:
  private val converterFactory =
      jsonSerializer.asConverterFactory(&#34;application/json&#34;.toMediaType())

  // permettra d&#39;impl√©menter les services que nous allons cr√©er:
  private val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .client(okHttpClient)
    .addConverterFactory(converterFactory)
    .build()
}
</code></pre>
<h2 is-upgraded>UserInfo</h2>
<p>Exemple de json renvoy√© par la route <code>/info</code>:</p>
<pre><code language="language-json" class="language-json">{
  &#34;email&#34;: &#34;email&#34;,
  &#34;firstname&#34;: &#34;john&#34;,
  &#34;lastname&#34;: &#34;doe&#34;
}
</code></pre>
<p>Cr√©er la <code>data class</code> <code>UserInfo</code> avec des annotations de KotlinX Serialization pour r√©cup√©rer ces donn√©es:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Serializable
data class UserInfo(
  @SerialName(&#34;email&#34;)
  val email: String,
  @SerialName(&#34;firstname&#34;)
  val firstName: String,
  @SerialName(&#34;lastname&#34;)
  val lastName: String
)
</code></pre>
<h2 is-upgraded>UserService</h2>
<ul>
<li>Cr√©ez l&#39;interface <code>UserService</code> pour requ√™ter les infos de l&#39;utilisateur (importez <code>Response</code> avec <code>alt + enter</code> et choisissez la version <code>retrofit</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">interface UserService {
  @GET(&#34;users/info&#34;)
  suspend fun getInfo(): Response&lt;UserInfo&gt;
}
</code></pre>
<ul>
<li>Utilisez retrofit pour cr√©er une impl√©mentation de ce service (grace aux annotations):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object Api {
  // ...
  val userService: UserService by lazy {
    retrofit.create(UserService::class.java)
  }
}
</code></pre>
<h2 is-upgraded>Affichage</h2>
<ul>
<li>Dans <code>fragment_task_list.xml</code>, ajoutez une <code>TextView</code> au dessus de la liste de t√¢che si vous n&#39;en avez pas</li>
<li>Overrider la m√©thode <code>onResume</code> pour y r√©cup√©rer les infos de l&#39;utilisateur, en ajoutant cette ligne, une erreur va s&#39;afficher mais ne paniquez pas, on va s&#39;en occuper:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">// Ici on ne va pas g√©rer les cas d&#39;erreur donc on force le crash avec &#34;!!&#34;
val userInfo = Api.userService.getInfo().body()!!
</code></pre>
<ul>
<li>La m√©thode <code>getInfo()</code> √©tant d√©clar√©e comme <code>suspend</code>, vous aurez besoin de la lancer dans un <code>CouroutineScope</code> (c&#39;est ce que dit le message d&#39;erreur):on va utiliser directement <code>lifeCycleScope</code> qui est un <code>CouroutineScope</code> d√©j√† d√©fini et g√©r√© par le syst√®me dans les <code>Activity</code> et <code>Fragment</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">lifecycleScope.launch {
  mySuspendMethod()
}
</code></pre>
<ul>
<li>Afficher les donn√©es dans votre <code>TextView</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">userInfoTextView.text = &#34;${userInfo.firstName} ${userInfo.lastName}&#34;
</code></pre>
<p>‚ö†Ô∏è Sur √©mulateur, vous aurez parfois des crashes √©tranges:</p>
<ul>
<li>&#34;<code>...EPERM (operation not permitted)...</code>&#34;: d√©sinstallez l&#39;application de l&#39;√©mulateur et relancez</li>
<li>L&#39;app stoppe direct et sans stacktrace: red√©marrer l&#39;√©mulateur et v√©rifiez que son wifi est bien connect√©</li>
</ul>
<p>‚û°Ô∏è Lancez l&#39;app et v√©rifiez que vos infos s&#39;affichent !</p>
<p><strong>Remarque:</strong></p>
<p>Un autre scope est fourni par android: <code>viewModelScope</code>, mais pour l&#39;instant on impl√©mente tout dans les fragments comme des üê∑</p>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListFragment" duration="0">
        <p>Il est temps de r√©cuperer les t√¢ches depuis le serveur !</p>
<ul>
<li>Cr√©er un nouveau service <code>TaskWebService</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">interface TasksWebService {
  @GET(&#34;tasks&#34;)
  suspend fun getTasks(): Response&lt;List&lt;Task&gt;&gt;
}
</code></pre>
<ul>
<li>Utiliser l&#39;instance de retrofit comme pr√©c√©demment pour cr√©er une instance de <code>TasksWebService</code> dans l&#39;objet <code>Api</code></li>
<li>Modifier <code>Task</code> pour la rendre lisible par KotlinX Serialization (i.e. faire comme pour <code>UserInfo</code>)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="TasksRepository" duration="0">
        <p>Le but d&#39;un Repository est d&#39;exposer des data venant d&#39;une ou plusieurs sources de donn√©es (ex: DB locale et API distante)</p>
<p>Cr√©er la classe <code>TasksRepository</code> avec:</p>
<ul>
<li>une propri√©t√© <code>tasksWebService</code> pour les requ√™tes avec <code>Retrofit</code></li>
<li>une propri√©t√© <code>taskList</code> <em>publique</em> de type <code>LiveData<List<Task>></code>: repr√©sente une liste de t√¢che <em>Observable</em> (on peut donc s&#39;<em>abonner</em> √† ses modifications) non modifiable afin de l&#39;exposer √† l&#39;ext√©rieur du repository</li>
<li>une propri√©t√© <code>_taskList</code> <em>priv√©e</em> de type <code>MutableLiveData<List<Task>></code> qui repr√©sente la m√™me donn√©e mais modifiable donc utilisable √† l&#39;int√©rieur du repository</li>
<li>une m√©thode publique <code>refresh</code> qui requ√™te la liste et met √† jour la <code>LiveData</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class TasksRepository {
  private val tasksWebService = Api.tasksWebService
  
  // Ces deux variables encapsulent la m√™me donn√©e:
  // [_taskList] est modifiable mais priv√©e donc inaccessible √† l&#39;ext√©rieur de cette classe
  private val _taskList = MutableLiveData&lt;List&lt;Task&gt;&gt;()
  // [taskList] est publique mais non-modifiable:
  // On pourra seulement l&#39;observer (s&#39;y abonner) depuis d&#39;autres classes
  public val taskList: LiveData&lt;List&lt;Task&gt;&gt; = _taskList

  suspend fun refresh() {
      // Call HTTP (op√©ration longue):
      val tasksResponse = tasksWebService.getTasks()
      // √Ä la ligne suivante, on a re√ßu la r√©ponse de l&#39;API:
      if (tasksResponse.isSuccessful) {
          val fetchedTasks = tasksResponse.body()
          // on modifie la valeur encapsul√©e, ce qui va notifier ses Observers et donc d√©clencher leur callback
          _taskList.value = fetchedTasks
      }
  }
}

</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="LiveData" duration="0">
        <p>Dans <code>TaskListFragment</code>:</p>
<ul>
<li>Ajouter en propri√©t√© une instance de <code>TasksRepository</code></li>
<li>Dans <code>onViewCreated()</code>, &#34;abonnez&#34; le fragment √† la  <code>LiveData</code> du repository</li>
<li>Mettez √† jour la liste et l&#39;<code>adapter</code> avec le r√©sultat (importer le <code>Observer</code> de la lib <code>lifecycle</code>)</li>
<li>Dans <code>onResume()</code>, utilisez le repository pour rafra√Æchir la liste de tasks</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private val tasksRepository = TasksRepository()

// Dans onViewCreated()
tasksRepository.taskList.observe(viewLifecycleOwner) { list -&gt;
  // mettre √† jour la liste dans l&#39;adapteur
}

// Dans onResume()
lifecycleScope.launch {
  tasksRepository.refresh()
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Compl√©ter TasksWebService" duration="0">
        <p>Modifier <code>TasksWebService</code> et ajoutez y les routes suivantes:</p>
<pre><code language="language-kotlin" class="language-kotlin">@DELETE(&#34;tasks/{id}&#34;)
suspend fun deleteTask(@Path(&#34;id&#34;) id: String?): Response&lt;Unit&gt;

@POST(&#34;tasks&#34;)
suspend fun createTask(@Body task: Task): Response&lt;Task&gt;

@PATCH(&#34;tasks/{id}&#34;)
suspend fun updateTask(@Body task: Task, @Path(&#34;id&#34;) id: String? = task.id): Response&lt;Task&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Suppression, Ajout, √âdition" duration="0">
        <ul>
<li>Inspirez vous du fonctionnement de <code>refresh()</code> pour ajouter toutes les autres actions avec le serveur dans le Repository, par ex pour l&#39;√©dition (les autres sont plus simples):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">suspend fun updateTask(task: Task) {
  // TODO appel r√©seau et r√©cup√©rationd de la tache:
  val updatedTask = ...
  // version &#34;mutable&#34; de la liste actuelle:
  val mutableList = _tasksList.value.orEmpty().toMutableList()
  // position actuelle de l&#39;√©l√©ment:
  val position = editableList.indexOfFirst { updatedTask.id == it.id }
  // modification de la liste mutable:
  editableList[position] = updatedTask
  // mise √† jour de la livedata pour notifier les observers:
  _tasksList.value = editableList
}
</code></pre>
<ul>
<li>Utilisez les m√©thodes du repository dans le Fragment, par ex pour la suppression:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">adapter.onClickDelete = { task -&gt;
  lifecycleScope.launch {
      tasksRepository.delete(task)
  }
}
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
