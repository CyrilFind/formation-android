
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TP 1 - Classic Views</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="TP1"
                  title="TP 1 - Classic Views"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Objectif" duration="0">
        <p>Ici on va utiliser le syst√®me de vue &#34;classique&#34; et afficher une liste d&#39;√©l√©ments modifiable</p>
<aside class="warning"><p>‚ö†Ô∏è Lisez toutes les questions: souvent vous bloquez simplement parce que vous n&#39;avez pas encore regard√© l&#39;√©tape suivante ou le sujet dans son ensemble.</p>
<p><strong>Sinon, demandez moi!!</strong></p>
<p>Si vous remarquez des erreurs, des fautes de frappe ou des oublis de ma part, n&#39;h√©sitez pas √† me le signaler SVP !</p>
</aside>
<aside class="special"><p>Remarque: si vous n&#39;avez pas bien param√©tr√© votre IDE, relisez le d√©but du TP0</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Cr√©er un projet" duration="0">
        <p>Vous allez cr√©er un unique projet que vous mettrez √† jour au fur √† mesure des TPs:</p>
<ul>
<li>Cr√©er un nouveau projet avec une <code>Empty VIEWS Activity</code> (‚ö†Ô∏è pas <code>Empty Activity</code> SVP ‚ö†Ô∏è)</li>
<li>Donnez lui un nom personnalis√© comme <code>TodoNicolasAlexandre</code> (‚ö†Ô∏è pas <code>TP1</code> SVP ‚ö†Ô∏è)</li>
<li>Choisissez un package name unique de ce genre: <code>com.something.todo</code> (ce sera la racine de tous vos packages et sert d&#39;identifiant unique d&#39;application)</li>
<li>Minimum API Level: laissez la valeur propos√©e par d√©faut</li>
<li>Initialisez un projet git et faites un commit initial</li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è Le projet va √©voluer au cours des TP donc faites des commits r√©guli√®rement: √† chaque √©tape et au minimum √† la fin de chaque TP</p>
<p>Comme dans un vrai projet professionnel, vous allez parfois supprimer et remplacer des parties de code: ne commentez pas votre code dans tous les sens car les commits garderons l&#39;historique et je noterai la &#34;propret√©&#34; du code √† la fin !</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Image Asset Studio" duration="0">
        <p>Cr√©ez une ic√¥ne d&#39;application personnalis√©e avec l&#39;outil int√©gr√© <strong>Image Asset Studio</strong>: ouvrez le <strong>Resource Manager</strong> √† gauche, pr√®s du volet projet puis cliquez sur le <code>+</code> en haut √† gauche et choisissez <code>Image Asset</code>: ici vous pouvez choisie une couleur de fond, une image: ic√¥ne syst√®me ou personnalis√©e avec un SVG ou un &#34;clipart&#34; (bibliotheque d&#39;icones en cliquant sur la petite icon android) et g√©n√©rer automatiquement les diff√©rentes tailles n√©cessaires pour les diff√©rentes version d&#39;Android.</p>
<aside class="warning"><p>N&#39;y passez pas trop de temps, mais profitez en pour r√©fl√©chir √† votre projet perso et si vous avez d√©j√† une id√©e, faites une ic√¥ne en rapport ! (sinon vous pourrez la changer plus tard)</p>
</aside>
<p>V√©rifiez que l&#39;ic√¥ne est bien prise en compte dans le <code>AndroidManifest.xml</code> (attribut <code>android:icon</code> de la balise <code>application</code>) et en lan√ßant l&#39;app.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Gestion des fichiers" duration="0">
        <p>üìÅ Les fichiers source Java ou Kotlin sont rang√©s en &#34;packages&#34;:</p>
<ul>
<li>not√©s en haut de chaque classe: <code>package com.nicoalex.todo.nomdupackage</code></li>
<li>r√©pliqu√©s en tant que dossiers dans le filesystem: <code>com/nicoalex/todo/nomdupackage</code></li>
</ul>
<aside class="special"><p>Dans le volet <strong>Projet</strong> √† gauche, vous pouvez choisir diverses visualisations de vos fichiers: la plus adapt√©e pour nous est <strong>Android</strong> qui affiche facilement le Manifest, les fichiers source, les fichier resources (<code>res</code>), compacte les dossiers vides ensemble (<code>com.nicoalex.todo</code>): tout ce qui est utile sp√©cifiquement pour Android...</p>
<p>Mais il peut parfois √™tre pratique de passer en <strong>Project Files</strong> par ex pour voir l&#39;arborescence r√©elle et certains fichiers qui sont cach√©s en vue <strong>Android</strong>.</p>
</aside>
<p>Parcourez les diff√©rents fichiers de config, notamment les plus importants:</p>
<ul>
<li><code>app/build.gradle.kts</code>: contient la configuration de module principal (<code>app</code>), notamment les versions compatibles, son propre num√©ro de version, etc et surtout les diff√©rentes d√©pendances.</li>
<li><code>./build.gradle.kts</code>: contient moins de choses, en g√©n√©ral des plugins, mais concerne tout le projet</li>
<li><code>libs.versions.toml</code>: un catalogue de d√©pendances, de plugins et de versions, qui est utilis√© par les fichiers pr√©c√©dents. V√©rifiez que vous utilisez les derni√®res versions disponible, surtout pour <code>kotlin</code>.</li>
<li><code>app/src/main/AndroidManifest.xml</code>: contient les info de packaging de l&#39;app comme les activit√©s existantes, le nom de l&#39;app, l&#39;ic√¥ne, etc.</li>
</ul>
<aside class="warning"><p>Les packages surlign√©s en vert contiennent le code de test uniquement: ne vous en occupez pas pour l&#39;instant</p>
</aside>
<p>Cr√©ez un nouveau package <code>list</code> √† l&#39;int√©rieur votre package source de base (pas √† c√¥t√© !) :</p>
<p><code>clic droit sur 'com.nicoalex.todo' > new > package > tapez 'list'</code></p>
<p>Vous y mettrez tous les fichiers source (Kotlin) concernant la liste de t√¢ches</p>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListFragment" duration="0">
        <ul>
<li>Cr√©ez dans votre nouveau package un fichier kotlin <code>TaskListFragment.kt</code> qui contiendra la classe <code>TaskListFragment</code>:</li>
<li>Cr√©er le layout associ√© <code>fragment_task_list.xml</code> dans <code>res/layout</code></li>
</ul>
<aside class="special"><p>vous pouvez aussi utiliser Android Studio pour cr√©er les 2 fichiers √† la fois: <code>Clic droit sur le package > New > Fragment > Fragment (Blank)</code>, mais la classe sera remplie de plein de code inutile -&gt; supprimez-le</p>
</aside>
<ul>
<li>Dans <code>TaskListFragment</code>, overrider la m√©thode <code>onCreateView(...)</code>: commencez √† taper <code>onCrea...</code> et utilisez l&#39;auto-completion de l&#39;IDE pour vous aider (vous pouvez supprimer la ligne <code>super.onCreateView(...)</code>)</li>
<li>On aura besoin ensuite d&#39;overrider <code>onViewCreated(...)</code> aussi, faites le maintenant de la m√™me fa√ßon, vous devriez avoir quelque chose comme √ßa:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class TaskListFragment : Fragment() {
    override fun onCreateView(...): View {
       // ici on cr√©e la vue et on la retourne (regardez le type de retour: `View`), on ne fait rien d&#39;autre.
    }

    override fun onViewCreated(...) {
       // ici la vue est cr√©√©e, on peut r√©cup√©rer des r√©f√©rences aux vues et les manipuler
    }
}
</code></pre>
<ul>
<li>Cette m√©thode vous demande de <strong>retourner</strong> la <code>rootView</code> √† afficher: cr√©ez la √† l&#39;aide de votre nouveau layout comme ceci:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val rootView = inflater.inflate(R.layout.fragment_task_list, container, false)
</code></pre>
<aside class="warning"><p>‚ö†Ô∏è Si vous ex√©cutez du code <strong>avant</strong> cette ligne <code>inflate</code>, il va crasher ou ne rien faire car votre vue n&#39;existera pas encore</p>
</aside>
<aside class="special"><p>üßë‚Äçüè´ <code>R</code> est un raccourci signifiant &#34;Resource&#34;: c&#39;est une classe g√©n√©r√©e automatiquement √† partir des dossiers et fichiers cr√©√©s dans <code>res</code> qui s&#39;utilise comme ceci: <code>R.string.app_name</code>, <code>R.drawable.app_icon</code>, etc... afin de r√©cup√©rer des ID que l&#39;on utilise dans les fonctions du framework Android (<code>getString</code>, <code>getDrawable</code>, etc...) grace aux noms des resources: pour les fichiers le nom sera toujours le nom du fichier sans l&#39;extension</p>
</aside>
<ul>
<li>Pour l&#39;instant, la liste des t√¢ches sera simplement une liste de <code>String</code> locale, ajoutez la en tant que propri√©t√© de votre classe <code>TaskListFragment</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private val taskList = listOf(&#34;Task 1&#34;, &#34;Task 2&#34;, &#34;Task 3&#34;)
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ Ici le <strong>Typage Statique Inf√©r√©</strong> de Kotlin nous permet de ne pas pr√©ciser le type de <code>taskList</code>: le compilateur le devine tout seul (et l&#39;IDE devrait vous l&#39;afficher en gris√©)</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="MainActivity" duration="0">
        <p>Cette activity va servir de conteneur de fragments:</p>
<p>Dans <code>activity_main.xml</code>, remplacez la balise <code>TextView</code> par celle ci et adaptez:</p>
<pre><code language="language-xml" class="language-xml"> &lt;androidx.fragment.app.FragmentContainerView
    android:name=&#34;com.nicoalex.todo.list.TaskListFragment&#34;
    android:id=&#34;@+id/fragment_container&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;match_parent&#34; /&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListAdapter: Cr√©ation" duration="0">
        <ul>
<li>Dans un nouveau fichier <code>TaskListAdapter.kt</code>, cr√©ez 2 nouvelles classes: <code>TaskListAdapter</code> et <code>TaskViewHolder</code>:</li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è l&#39;IDE va vous signaler un probl√®me ici, c&#39;est normal, on le r√©glera plus tard</p>
</aside>
<pre><code language="language-kotlin" class="language-kotlin">class TaskListAdapter : RecyclerView.Adapter&lt;TaskListAdapter.TaskViewHolder&gt;() {

  var currentList: List&lt;String&gt; = emptyList()

  // on utilise `inner` ici afin d&#39;avoir acc√®s aux propri√©t√©s de l&#39;adapter directement
  inner class TaskViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    fun bind(taskTitle: String) {
      // on affichera les donn√©es ici
    }
  }
}
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ Une <a href="../../slides/04%20-%20RecyclerView.html" target="_blank">RecyclerView</a> est un composant Android qui permet d&#39;afficher une liste de donn√©es de mani√®re performante et fonctionne avec un <strong>Adapter</strong> qui lui &#34;explique&#34; comment &#34;recycler&#34; en <strong>impl√©mentant</strong> plusieurs m√©thodes</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListAdapter: Utilisation" duration="0">
        <ul>
<li>Dans <code>TaskListFragment</code>, cr√©ez une instance de votre nouvelle classe <code>TaskListAdapter</code> en propri√©t√© de votre fragment (comme <code>taskList</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private val adapter = TaskListAdapter()
</code></pre>
<ul>
<li>connectez le √† votre source de donn√©es dans <code>onCreateView</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">adapter.currentList = taskList
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="RecyclerView" duration="0">
        <ul>
<li>Dans le layout associ√© √† <code>TaskListFragment</code>, placez une balise <code>RecyclerView</code> (vous pouvez taper <code>< Recyc...</code> et vous aider de l&#39;auto-compl√©tion ou bien utilisez le mode visuel)</li>
<li>ajoutez lui l&#39;attribut <code>layoutManager</code> qui lui dit de s&#39;afficher comme une liste (verticale par d√©faut):</li>
</ul>
<pre><code language="language-xml" class="language-xml">app:layoutManager=&#34;androidx.recyclerview.widget.LinearLayoutManager&#34;
</code></pre>
<aside class="warning"><p>‚ö†Ô∏è Utilisez l&#39;IDE pour r√©gler le probl√®me qu&#39;il vous signale: seul le pr√©fixe <code>android:</code>, correspondant au framework Android, est reconnu par d√©faut, et il faut donc ajouter une sorte d&#39;√©quivalent de <code>import</code> mais dans le XML, pour que le pr√©fixe <code>app:</code>, correspondant √† des attributs additionnels d√©fini par ex dans des lib (ici <code>recyclerview</code>) soit reconnu.</p>
</aside>
<ul>
<li>ajoutez lui un <code>id</code>: soit en mode visuel soit en mode code, en vous aidant de l&#39;auto-compl√©tion <code>android:id="@+id/id_de_votre_recycler_view</code></li>
<li>Dans <code>TaskListFragment</code>, overridez <code>onViewCreated</code> pour y r√©cup√©rez une r√©f√©rence √† la <code>RecyclerView</code> du layout en utilisant <code>findViewById</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val recyclerView = view.findViewById&lt;RecyclerView&gt;(R.id.id_de_votre_recycler_view)
</code></pre>
<ul>
<li>Pour fonctionner, <code>recyclerView</code> a une propri√©t√© <code>adapter</code> qui doit √™tre connect√©e √† l&#39;adapter que vous avez cr√©√© (<code>null</code> par d√©faut)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Item View" duration="0">
        <ul>
<li>Cr√©er un layout <code>item_task.xml</code> qui servira √† afficher chaque cellule de la liste avec comme racine un <code>LinearLayout</code> contenant pour l&#39;instant une seule <code>TextView</code> en enfant:</li>
</ul>
<pre><code language="language-xml" class="language-xml">&lt;LinearLayout
  xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
  android:orientation=&#34;vertical&#34;
  android:layout_width=&#34;match_parent&#34;
  android:layout_height=&#34;wrap_content&#34;&gt;

  &lt;TextView
      android:id=&#34;@+id/task_title&#34;
      android:background=&#34;@android:color/holo_blue_bright&#34;
      android:layout_width=&#34;match_parent&#34;
      android:layout_height=&#34;wrap_content&#34; /&gt;
&lt;/LinearLayout&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="TaskListAdapter: Impl√©mentation" duration="0">
        <aside class="special"><p><strong>Rappel</strong>: l&#39;Adapter g√®re le recyclage des cellules (<code>ViewHolder</code>): il <code>inflate</code> un nombre suffisant de &#34;coquilles vides&#34; pour remplir l&#39;√©cran une seule fois (co√ªteux) puis injecte seulement les donn√©es dedans quand on scroll (peu co√ªteux)</p>
</aside>
<p>Dans <code>TaskListAdapter</code>, impl√©menter toutes les m√©thodes requises:</p>
<p><strong>Astuce</strong>: Pr√©-remplissez votre adapter en cliquant sur le nom de votre classe (qui doit √™tre pour l&#39;instant soulign√©e en rouge) et cliquez sur l&#39;ampoule jaune ou tapez <code>Alt</code> + <code>ENTER</code> (sinon, <code>CTRL/CMD</code> + <code>o</code> n&#39;importe o√π dans la classe)</p>
<ul>
<li><code>getItemCount</code> doit renvoyer la taille de la liste de t√¢che √† afficher</li>
<li><code>onCreateViewHolder</code> doit retourner un nouveau <code>TaskViewHolder</code> en g√©n√©rant un <code>itemView</code>, √† partir du layout <code>item_task.xml</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_task, parent, false)
</code></pre>
<ul>
<li><code>onBindViewHolder</code> doit ins√©rer la donn√©e dans la cellule (<code>TaskViewHolder</code>) en fonction de sa <code>position</code> dans la liste en utilisant la m√©thode <code>bind()</code> que vous avez cr√©√©e dans <code>TaskViewHolder</code> (elle ne fait rien pour l&#39;instant)</li>
<li>Impl√©mentez maintenant <code>bind()</code> qui doit r√©cup√©rer une r√©f√©rence √† la <code>TextView</code> dans <code>item_task.xml</code> et y ins√©rer le texte r√©cup√©r√© en argument (pour √™tre plus propre, d√©placez cette r√©f√©rence en tant que propri√©t√© de votre <code>TaskViewHolder</code>)</li>
<li>Lancez l&#39;app: vous devez voir 3 t√¢ches s&#39;afficher üëè</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Data class" duration="0">
        <ul>
<li>Dans un nouveau fichier, cr√©er une <code>data class Task</code> avec 3 attributs: un id, un titre et une description</li>
<li>Ajouter une valeur par d√©faut √† la description.</li>
<li>Dans le <code>TaskListFragment</code>, remplacer la liste <code>taskList</code> par</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private val taskList = listOf(
   Task(id = &#34;id_1&#34;, title = &#34;Task 1&#34;, description = &#34;description 1&#34;),
   Task(id = &#34;id_2&#34;, title = &#34;Task 2&#34;),
   Task(id = &#34;id_3&#34;, title = &#34;Task 3&#34;)
)
</code></pre>
<ul>
<li>Corriger et adapter votre code en cons√©quence afin qu&#39;il compile de nouveau en utilisant votre <code>data class</code> √† la place de simples <code>String</code></li>
<li>Ajoutez la description en dessous du titre (avec une seconde <code>TextView</code>)</li>
<li>Admirez avec fiert√© le travail accompli ü§©</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout du FAB" duration="0">
        <ul>
<li>Changez la root view de <code>fragment_task_list.xml</code> en <code>ConstraintLayout</code> (si ce n&#39;est pas d√©j√† fait) en faisant un clic droit dessus en mode design</li>
<li>Ouvrez le volet <code>Resource Manager</code> √† gauche, cliquez sur le <code>+</code> en haut √† gauche puis <code>Vector Asset</code> puis double cliquez sur l&#39;image du logo android et trouvez une ic√¥ne <code>+</code> (en tapant <code>add</code>) puis <code>finish</code> pour ajouter une ic√¥ne √† vos resource</li>
<li>Ajouter un <code>Floating Action Button</code> (FAB) en bas √† droite de ce layout et utilisez l&#39;ic√¥ne cr√©√©e</li>
<li>Donnez des contraintes en bas et √† droite √† ce bouton</li>
</ul>
<aside class="special"><p>Vous pouvez configurer les contraintes de plusieurs fa√ßons:</p>
<ul>
<li>soit manuellement,</li>
<li>soit en activant l&#39;ic√¥ne &#34;Aimant üß≤&#34;: d√©placez le bouton, attendez de voir appara√Ætre des lignes pointill√©es et rel√¢chez le .</li>
<li>soit en pla√ßant la vue dans l&#39;outil visuel puis en cliquant sur l&#39;ic√¥ne &#34;baguette magique ü™Ñ&#34; qui va essayer de &#34;deviner&#34; les contraintes qu&#39;il faut automatiquement (√ßa ne marche pas toujours bien)</li>
</ul>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout de t√¢che rapide" duration="0">
        <p>Retournez dans le code, r√©cup√©rez une r√©f√©rence √† votre nouveau bouton et utilisez <code>.setOnClickListener {}</code> pour ajouter une t√¢che √† votre liste √† chaque fois qu&#39;on clique dessus:</p>
<pre><code language="language-kotlin" class="language-kotlin">// Instanciation d&#39;un objet task avec des donn√©es pr√©remplies:
val newTask = Task(id = UUID.randomUUID().toString(), title = &#34;Task ${taskList.size + 1}&#34;)
taskList = taskList + newTask
</code></pre>
<aside class="warning"><p>‚Ü≥ vous allez devoir changer <code>taskList</code> en <code>var</code> car actuellement le <code>val</code> signifie que la variable est immuable (ne peut pas √™tre r√©assign√©e) donc √ßa ne compilera pas.</p>
<p>On pourrait aussi garder <code>val</code> mais utiliser une structure de donn√©es mutable: <code>MutableList</code>, dans ce cas la variable ne change pas mais c&#39;est son <strong>contenu</strong> qui change.</p>
</aside>
<aside class="warning"><p>‚ö†Ô∏è Votre modification de liste ne va pas s&#39;afficher directement, il faut:</p>
<ul>
<li>passer la nouvelle liste √† votre adapter</li>
<li>puis le <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyDataSetChanged()" target="_blank"><strong>notifier</strong></a> que la donn√©e a chang√©</li>
</ul>
<p>‚û° cr√©ez une m√©thode <code>refreshAdapter</code> qui va faire les deux actions ci-dessus afin de rendre cela r√©utilisable</p>
</aside>
<p>Cette fa√ßon de &#34;notifier&#34; manuellement n&#39;est pas id√©ale, il existe en fait une sous-classe de <code>RecyclerView.Adapter</code> qui permet de g√©rer cela automatiquement: <code>ListAdapter</code></p>


      </google-codelab-step>
    
      <google-codelab-step label="ListAdapter" duration="0">
        <p>Am√©liorer l&#39;impl√©mentation de <code>TasksListAdapter</code> en h√©ritant de <a href="https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter" target="_blank"><code>ListAdapter</code></a> au lieu de <code>RecyclerView.Adapter</code></p>
<p>Il faudra notamment: cr√©er un <code>DiffUtil.ItemCallback<Task></code> et le passer au constructeur parent, supprimer <code>getItemCount</code> et la propri√©t√© <code>currentList</code> car ils sont d√©j√† d√©finis dans <code>ListAdapter</code></p>
<p>Exemple:</p>
<pre><code language="language-kotlin" class="language-kotlin">object MyItemsDiffCallback : DiffUtil.ItemCallback&lt;MyItem&gt;() {
   override fun areItemsTheSame(oldItem: MyItem, newItem: MyItem) : Boolean {
      return // comparaison: est-ce la m√™me &#34;entit√©&#34; ? =&gt; m√™me id?
   }

   override fun areContentsTheSame(oldItem: MyItem, newItem: MyItem) : Boolean {
      return // comparaison: est-ce le m√™me &#34;contenu&#34; ? =&gt; m√™mes valeurs? (avec data class: simple √©galit√©)
   }
}

class ItemListAdapter : ListAdapter&lt;Item, ItemListAdapter.ItemViewHolder&gt;(ItemsDiffCallback) {
   override fun onCreateViewHolder(...)
   override fun onBindViewHolder(...)
}

// Usage is simpler:
val adapter = ItemListAdapter()
recyclerView.adapter = adapter
adapter.submitList(listOf(&#34;Item#1&#34;, &#34;Item #2&#34;))
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Scroll" duration="0">
        <ul>
<li>Faites maintenant une liste de 100 √©l√©ments pour tester le scroll:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private val taskList = List(100) { index -&gt;
    Task(id = &#34;id_$index&#34;, title = &#34;Task $index&#34;)
}
</code></pre>
<ul>
<li>Vous pouvez tester avec 1000 ou 10.000 √©l√©ments aussi: √ßa doit rester fluide !</li>
<li>remettez 100 √©l√©ments pour la suite: mainteant si vous ajoutez un √©l√©ment, vous ne le verrez pas forc√©ment !</li>
<li>faites en sorte que le <code>RecyclerView</code> scrolle automatiquement en bas √† chaque ajout de t√¢che: <code>recyclerView.smoothScrollToPosition(...)</code></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ViewBinding" duration="0">
        <p>Utiliser le <code>ViewBinding</code> (<a href="https://developer.android.com/topic/libraries/view-binding" target="_blank">documentation</a> / <a href="../../slides/3%20-%20Views.html#9" target="_blank">slides</a>) dans <code>TaskListFragment</code>:</p>
<ul>
<li>changez le <code>inflate</code> pour r√©cup√©rer une instance de type <code>XxxBinding</code></li>
<li>remplacez les <code>findViewByIds</code> par des calls direct du genre <code>binding.myViewId</code></li>
</ul>
<p>Puis faites pareil pour les <code>ViewHolder</code>: c&#39;est un peu plus complexe, il faudra changer le constructeur pour qu&#39;il prenne un <code>val binding: ItemTaskBinding</code> afin d&#39;y avoir acc√®s dans le corps de la classe et passer <code>binding.root</code> au constructeur parent.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Suppression d&#39;une tache" duration="0">
        <p>Dans le layout de vos item, ajouter un <code>ImageButton</code> qui servira √† supprimer la t√¢che associ√©e. Vous pouvez utiliser par exemple l&#39;ic√¥ne <code>@android:drawable/ic_menu_delete</code></p>
<aside class="special"><p>üßë‚Äçüè´ Une <a href="https://kotlinlang.org/docs/reference/lambdas.html" target="_blank">lambda</a> est un type de variable qui contient un bloc de code pouvant prendre des arguments et retourner un r√©sultat</p>
<p>C&#39;est donc une fonction que l&#39;on peut utiliser comme une variable !</p>
</aside>
<p>Aidez vous des lignes de code plus bas pour r√©aliser un &#34;Click Listener&#34; √† l&#39;aide d&#39;une lambda en suivant ces √©tapes:</p>
<ul>
<li>Dans l&#39;adapter, ajouter une propri√©t√© <code>onClickDelete</code> de type lambda qui prends en arguments une <code>Task</code> et ne renvoie rien: <code>(Task) -> Unit</code> et l&#39;initier √† <code>{}</code> (elle ne fait rien par d√©faut)</li>
<li>Utilisez cette lambda dans le <code>onClickListener</code> du bouton supprimer</li>
<li>Dans le fragment, acc√©der √† <code>onClickDelete</code> depuis l&#39;adapter et impl√©mentez l√†: donnez lui comme valeur une lambda qui va supprimer la tache pass√©e en argument de la liste</li>
<li>D√©claration de la variable lambda dans l&#39;adapter, par d√©faut elle ne fait rien (<code>{}</code>):</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">var onClickDelete: (Task) -&gt; Unit = {}
</code></pre>
<ul>
<li>Utilisation de la lambda dans le ViewHolder, quand on clique sur le bouton:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">onClickDelete(task)
</code></pre>
<ul>
<li>&#34;impl√©mentation&#34; de la lambda dans le fragment, pour que la lambda aie un effet on lui √©crit un comportement et on l&#39;assigne √† la variable:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">myAdapter.onClickDelete = { task -&gt;
    // Supprimer la t√¢che
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="DetailFragment" duration="0">
        <ul>
<li>Cr√©ez un formulaire simple dans <code>DetailFragment</code> en utilisant un <code>ConstraintLayout</code> (vous pouvez &#34;convert&#34; dans le menu du clic droit sur la root view) avec deux <code>EditText</code> (pour le titre et la description) et un <code>Button</code> de validation</li>
<li>Dans <code>DetailFragment</code>, r√©cup√©rez les r√©f√©rences aux vues et impl√©mentez le clic</li>
<li>Personnalisez un peu l&#39;UI si vous le souhaitez</li>
</ul>
<aside class="special"><p>En haut √† droite de votre √©diteur, il devrait y avoir trois ic√¥nes qui permettent d&#39;alterner entre mode texte, mode visuel, et les 2 ensemble: &#34;Split&#34;, je sais qu&#39;on aime le code ü§ì mais je vous conseille le mode visuel qui est plus simple pour manipuler les contraintes ou au moins le mode Split pour afficher la Preview sans avoir √† relancer l&#39;app √† chaque fois.</p>
<p class="image-container"><img alt="split" src="img/d5f599a5a4f785b5.png"></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout de t√¢che complet" duration="0">
        <aside class="special"><p>Afin de r√©cup√©rer un r√©sultat de cette nouvelle Activity, nous allons utiliser le fragmentManager qui permet de naviguer et communiquer entre fragments.</p>
<p>Il fonctionne √† base de &#34;transactions&#34; qui permettent d&#39;effectuer plusieurs actions √† la fois et de les &#34;commiter&#34; (valider) en une seule fois</p>
<p>Ici on utilisera une version simplifi√©e avec <code>commit { ... }</code> fournie par fragment-KTX qui permet d&#39;avoir automatiquement le commit √† la fin de la lambda de transaction.</p>
</aside>
<ul>
<li>v√©rifiez que vous avez les d√©pendances n√©cessaires (les derni√®res versions au moment o√π j&#39;√©cris sont les suivantes):</li>
<li>Dans <code>app/build.gradle.kts</code> &gt; <code>dependencies {...}</code>, ajoutez les d√©pendances qui vous manquent (mettre les versions plus r√©centes si l&#39;IDE vous le propose, il vous proposera √©galement de facilement les passer dans le fichier centralis√© <code>libs.versions.toml</code>):</li>
</ul>
<pre><code language="language-gradle" class="language-gradle">implementation(&#34;androidx.fragment:fragment:1.8.9&#34;)
implementation(&#34;androidx.fragment:fragment-ktx:1.8.9&#34;)
</code></pre>
<ul>
<li>Faire en sorte de lancer le nouveau fragment depuis le bouton + du 1er</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">parentFragmentManager.commit {
    replace&lt;DetailFragment&gt;(R.id.fragment_container)
    addToBackStack(null)
}
</code></pre>
<ul>
<li>Afin de pouvoir recevoir le r√©sultat de <code>DetailFragment</code>, cr√©ez un <code>FragmentResultLauncher</code> dans <code>TaskListFragment</code>:</li>
<li>V√©rifiez que vous naviguez bien vers l&#39;√©cran en cliquant sur + et qu&#39;il s&#39;affiche correctement</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class DetailFragment : Fragment() {
    override fun onViewCreated(...) {
        // ...
        parentFragmentManager.setFragmentResultListener(REQUEST_KEY) { _, bundle -&gt;
            val result = bundle.getString(RESULT_KEY)
            // Utilisez le r√©sultat ici
        }
    }

    companion object { // pour d√©finir des membres &#34;statiques&#34;, ici des constantes:
        const val REQUEST_KEY = &#34;request_key&#34;
        const val RESULT_KEY = &#34;result_key&#34;
    }
</code></pre>
<ul>
<li>Sur votre bouton de validation cr√©ez une nouvelle task:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val newTask = Task(id = UUID.randomUUID().toString(), title = &#34;New Task !&#34;)
</code></pre>
<ul>
<li>et passez la en r√©sultat au fragment parent avant de fermer le fragment:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">parentFragmentManager.setFragmentResult(BlankFragment.REQUEST_KEY, Bundle().apply {
  putString(BlankFragment.RESULT_KEY, newTask)
})
parentFragmentManager.popBackStack() // retour au fragment pr√©c√©dent
</code></pre>
<ul>
<li>√ßa ne compilera pas car <code>Task</code> ne fait pas partie des types de base autoris√©s dans un bundle !</li>
<li>L&#39;un de ces types est <code>Serializable</code>: Faites donc h√©riter <code>Task</code> de <code>java.io.Serializable</code>, comme c&#39;est une <code>data class</code>, il n&#39;y a rien √† impl√©menter !</li>
<li>Dans le FragmentResultListener de votre 1er fragment, r√©cup√©rez cette task:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val task = result.data?.getSerializableExtra(&#34;task&#34;) as Task?
</code></pre>
<ul>
<li>et ajoutez la √† la liste, comme vous le faisiez avec le bouton d&#39;ajout pr√©c√©demment</li>
</ul>
<aside class="warning"><p>La syntaxe <code>as Task</code> permet de <strong>&#34;caster&#34;</strong> un objet r√©cup√©r√© en tant que <code>Task</code>: c&#39;est √† dire qu&#39;on force l&#39;objet √† √™tre consid√©r√© de type <code>Task</code>, qui est (depuis l&#39;√©tape pr√©c√©dente) un sous-type de <code>Serializable</code> (retourn√© par <code>getSerializableExtra</code>)</p>
<p>ici on utilise <code>as Task?</code> (√©quivalent √† <code>as? Task</code>) pour r√©cup√©rer un <strong>nullable</strong> et √©viter d&#39;avoir une exception si le cast ne fonctionne pas en retournant <code>null</code> √† la place</p>
</aside>
<ul>
<li>V√©rifiez que la nouvelle tache s&#39;affiche dans la liste</li>
<li>Pour l&#39;instant notre Task est cr√©√©e avec des donn√©es &#34;en dur&#34;, modifiez le code de <code>DetailFragment</code> pour r√©cup√©rer les valeurs entr√©es par l&#39;utilisateur dans les <code>EditText</code> et les utiliser pour cr√©er la nouvelle t√¢che</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="√âdition d&#39;une t√¢che" duration="0">
        <aside class="special"><p>üßë‚Äçüè´ L&#39;avantage des Fragments est qu&#39;on peut les initialiser avec des arguments contrairement aux Activity (car celles ci doivent √™tre instanci√©es par le syst√®me)</p>
</aside>
<p>Ajoutez un argument taskId de type String?, <code>null</code> par d√©faut (pour garder le cas d&#39;ajout de nouvelle t√¢che) √† <code>DetailFragment</code> pour identifier la t√¢che √† √©diter, vous pourrez ensuite faire:</p>
<pre><code language="language-kotlin" class="language-kotlin">parentFragmentManager.commit {
    replace(R.id.fragmentContainerView, DetailFragment(taskId))
    addToBackStack(null)
}
</code></pre>
<p>Inspirez vous de ce que vous avez fait pour le bouton &#34;supprimer&#34; et le bouton &#34;ajouter&#34; pour cr√©er un bouton &#34;√©diter&#34; permettant de modifier chaque t√¢che en ouvrant l&#39;activit√© <code>DetailFragment</code> pr√©-remplie avec les informations de la t√¢che en question.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Interface et d√©l√©gation" duration="0">
        <p>Pour l&#39;instant on a utilis√© des lambda mais une fa√ßon plus classique de g√©rer les clicks d&#39;un item est de d√©finir une interface que l&#39;on impl√©mentera dans le 1er Fragment, mettez √† jour votre code pour utiliser cette m√©thode:</p>
<pre><code language="language-kotlin" class="language-kotlin">interface TaskListListener {
  fun onClickDelete(task: Task)
  fun onClickEdit(task: Task)
}

class TaskListAdapter(val listener: TaskListListener) : ... {
  // use: listener.onClickDelete(task)
}

class TaskListFragment : Fragment {
  val adapterListener : TaskListListener = object : TaskListListener {
    override fun onClickDelete(task: Task) {...}
    override fun onClickEdit(task: Task) {...}
  }
  val adapter = TaskListAdapter(adapterListener)
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Partager" duration="0">
        <ul>
<li>En modifiant <code>AndroidManifest.xml</code>, ajouter la possibilit√© de partager du texte <strong>depuis les autres applications</strong> (par ex en surlignant un texte dans un navigateur puis en cliquant sur &#34;partager&#34;) et ouvrir le formulaire de cr√©ation de t√¢che avec une description pr√©-remplie (<a href="https://developer.android.com/training/sharing/receive" target="_blank">Documentation</a>)</li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è Attention l&#39;Activity concern√©e devra avoir l&#39;attribut <code>exported="true"</code> dans le manifest</p>
</aside>
<ul>
<li>En utilisant un <code>Intent</code> <strong>implicite</strong>, ajouter la possibilit√© de partager du texte <strong>vers les autres applications</strong> (avec un <code>OnLongClickListener</code> sur les t√¢ches par ex ou bien avec un bouton dans la vue formulaire) (<a href="https://developer.android.com/training/sharing/send" target="_blank">Documentation</a>)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Changements de configuration" duration="0">
        <p>Que se passe-t-il pour votre liste si vous tournez votre t√©l√©phone pour passer en mode paysage ? ü§î</p>
<ul>
<li>Une fa√ßon de r√©gler ce soucis est d&#39;overrider la m√©thode <code>onSaveInstanceState</code></li>
<li>Il faudra utiliser <code>putSerializable</code> (un peu comme pr√©c√©demment avec <code>putExtra</code>) pour sauvegarder la liste</li>
<li>Puis pour r√©cup√©rer cette liste, la m√©thode <code>getSerializable</code> dans <code>onCreateView</code> ou <code>onViewCreated</code>, sur le param√®tre <code>savedInstanceState</code></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById("arrow-back").href="/formation-android/codelabs/";
            document.getElementById("done").href="/formation-android/codelabs/";
        }, false);
    </script>

    