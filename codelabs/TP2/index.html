
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TP 2 - Jetpack Compose</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="TP2"
                  title="TP 2 - Jetpack Compose"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Compose Activity" duration="0">
        <aside class="warning"><p>‚ö†Ô∏è Ne cr√©ez pas un nouveau projet, le but est que vous ayez un seul rendu √† m&#39;envoyer √† la fin !</p>
</aside>
<ul>
<li>Cr√©ez une nouvelle activity &#34;Empty Activity&#34; (en compose cette fois) appelez la <code>ComposeActivity</code></li>
<li>L&#39;IDE devrait automatiquement compl√©ter <code>app/build.gradle.kts</code> pour configurer Compose (buildFeatures, dependencies, etc) et l&#39;ajouter au <code>AndroidManifest.xml</code></li>
<li>Adaptez votre <code>AndroidManifest</code> pour en faire notre activity principale √† la place de l&#39;ancienne, et relancez l&#39;app pour v√©rifier: il faut d√©placer <code><intent-filter>...</intent-filter></code> de l&#39;ancienne activity √† la nouvelle</li>
<li>Renommez <code>Greeting</code> en <code>ListScreen</code> et <code>GreetingPreview</code> en <code>ListPreview</code> et supprimez l&#39;argument <code>name</code></li>
</ul>
<p>Vous devriez avoir quelque chose comme √ßa:</p>
<pre><code language="language-kotlin" class="language-kotlin">class ComposeActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        //...
        setContent {
            TodoTheme {
                ListScreen()
            }
        }
    }
}
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ <code>setContent</code> sert ici de &#34;point d&#39;entr√©e&#34; √† Compose: il va chercher une <code>ComposeView</code> dans le layout de votre <code>Activity</code>, et en cr√©er une sinon</p>
<p>Ensuite <code>TodoTheme</code> est une fonction <code>@Composable</code> qui applique un th√®me Material Design √† tout ce qui est √† l&#39;int√©rieur (couleurs, typographie, etc...)</p>
<p>Puis <code>ListScreen</code> : votre premier √©cran Compose, que vous allez maintenant impl√©menter</p>
</aside>
<ul>
<li>Personnalisez un peu votre Theme en fonction de votre projet perso !</li>
</ul>
<aside class="special"><p>En haut √† droite de votre √©diteur, il devrait y avoir trois ic√¥nes qui permettent d&#39;alterner entre mode texte, mode visuel, et les 2 ensemble: &#34;Split&#34;, je vous conseille ce mode Split pour afficher vos <code>@Preview</code> sans avoir √† relancer l&#39;app √† chaque fois.</p>
<p class="image-container"><img alt="split" src="img/d5f599a5a4f785b5.png"></p>
</aside>
<ul>
<li>affichez une liste d&#39;√©l√©ments avec Compose (utilisez <code>LazyColumn</code> et <code>items</code>), avec des √©l√©ments, c&#39;est l√©gerement plus simple qu&#39;une <code>RecyclerView</code> üôÉ :</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">LazyColumn{
    items(100) {
        Text(text = &#34;Item #$it&#34;)
    }
}
</code></pre>
<ul>
<li>Lancez l&#39;app et essayez de scroller la liste: attention, on ne voit pas les contours de la liste, mais elle ne prends pas toute la largeur actuellement donc le scroll ne marche que si on scroll pr√©cis√©ment sur les textes !</li>
<li>Pour r√©gler √ßa, ajoutez un <code>Modifier.fillMaxWidth()</code> √† la <code>LazyColumn</code></li>
<li>Ajoutez un <code>Modifier.padding(16.dp)</code> √† la <code>LazyColumn</code> pour ajouter un peu d&#39;espace autour</li>
<li>Essayez √† nouveau de scroller, vous devriez pouvoir le faire aussi en dehors des textes maintenant</li>
<li>Espacez un peu les √©l√©ments de la liste en lui passant <code>verticalArrangement = Arrangement.spacedBy(8.dp)</code> comme argument</li>
<li>Personnalisez un peu l&#39;affichage comme vous le souhaitez (couleurs, taille de texte, ...)</li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è Attention quand vous importez la class <code>Color</code> dans du Compose, il y a plusieurs choix, choisissez bien la version avec <code>compose</code> dans le nom de package et qui s&#39;√©crivent en &#34;TitleCase&#34; pas en &#34;UPPERCASE&#34;:</p>
<pre><code language="language-kotlin" class="language-kotlin">val blue = Color.Blue // Compose
val green = Color.GREEN // Views
</code></pre>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Remember" duration="0">
        <p>On va maintenant ajouter un peu d&#39;interactivit√© sur notre liste.</p>
<ul>
<li>Ajoutez une variable <code>items</code> en haut de <code>ListScreen</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">var items by remember { mutableStateOf(List(100) { &#34;Item #$it&#34; }) }
</code></pre>
<ul>
<li>faites les imports sugg√©r√©s par l&#39;IDE</li>
</ul>
<aside class="special"><p>üßë‚Äçüè´ Il se passe pas mal de chose sur cette seule ligne:</p>
<ul>
<li><code>remember</code>: Une fonction <code>@Composable</code> peut √™tre <em>recompos√©e</em> (en gros: r√©-ex√©cut√©e) √† tout moment donc on ne peut pas utiliser de variables simples car elles seraient remises √† leur valeur de d√©part en permanence, on utilise donc diverses formes de <code>remember</code> qui permettent √† nos variables de survivre aux recompositions.</li>
<li><code>mutableStateOf</code> cr√©e une variable de type <code>MutableState<T></code> qui est un &#34;wrapper&#34; autour de la valeur initiale et qui permet d&#39;observer les changement de valeur et de d√©clencher des recompositions automatiquement.</li>
<li>le mot cl√© de <em>d√©l√©gation </em><code>by</code> qui permet de ne pas avoir √† √©crire <code>items.value</code> ou <code>items.value = ...</code> partout dans le code, mais juste <code>items</code> ou <code>items = ...</code> directement, gr√¢ce √† l&#39;import des fonctions d&#39;extension <code>getValue</code> et <code>setValue</code> d√©finies pour <code>MutableState<T></code>, et au fait qu&#39;on a utilis√© <code>var</code> (sinon seul le <code>getValue</code> serait d√©l√©gu√©)</li>
</ul>
</aside>
<ul>
<li>Modifiez la liste pour qu&#39;elle utilise cette variable <code>items</code> au lieu de la liste statique: attention il faudrait importer une autre fonction <code>items</code> qui prend directement une <code>List<T></code> au lieu d&#39;un <code>Int</code> (l&#39;IDE devrait vous proposer l&#39;import automatiquement mais parfois il confond les 2)</li>
<li>lancez l&#39;app: √ßa devrait fonctionner pareil</li>
<li>Remplacez vos items en <code>String</code> par des <code>data class Task</code> et ajoutez la description:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">items(items) { task -&gt;
  Column {
    Text(text = task.title)
    Text(text = task.description)
  }
}
</code></pre>
<ul>
<li>lancez l&#39;app pour v√©rifier que tout s&#39;affiche correctement</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Scaffold" duration="0">
        <p>On va utiliser des √©l√©ments de &#34;Material Design 3&#34; pour am√©liorer un peu l&#39;interface facilement.</p>
<ul>
<li>Modifiez <code>ListScreen</code> pour qu&#39;elle utilise un <code>Scaffold</code>, avec une <code>TopAppBar</code> (acceptez de &#34;Opt-in √† ExperimentalMaterial3Api&#34;) avec le titre de votre choix</li>
<li>et un <code>FloatingActionButton</code> avec une ic√¥ne &#34;Add&#34;</li>
<li>passez le innerPadding du <code>Scaffold</code> √† la <code>LazyColumn</code> pour que le contenu ne soit pas cach√© par la <code>TopAppBar</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">Scaffold(
    modifier = Modifier.fillMaxSize(),
    topBar = { TopAppBar(title = { Text(/* title */) }) },
    floatingActionButton = {
        FloatingActionButton(onClick = { /* TODO */ }) {
          Icon(imageVector = Icons.Default.Add, contentDescription = &#34;Add&#34;)
        }
    }
) {
    LazyColumn() {
        // ...
    }
}
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ Ici on utilise ce qu&#39;on appelle des <strong>Slots</strong>: des fonctions Compose qu&#39;on passe en argument d&#39;autres fonctions compose via des <strong>lambda</strong></p>
<p>Par exemple <code>Scaffold</code> permet de placer un composant en haut (topBar), un en bas (bottomBar), un bouton flottant (floatingActionButton), etc...</p>
<p>Et juste apr√®s on va utiliser <code>actions</code> pour ajouter un bouton dans la <code>TopAppBar</code> (qui est d√©fini avec un <code>RowScope</code>, donc on peut y ajouter plusieurs √©l√©ments √† la suite ils seront plac√©s horizontalement).</p>
<p class="image-container"><img alt="slots" src="img/ca8c2366f08ebd11.png"></p>
</aside>
<ul>
<li>Lancez l&#39;app pour v√©rifier que tout s&#39;affiche correctement</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout d&#39;√©l√©ments" duration="0">
        <p>On va maintenant impl√©menter l&#39;ajout d&#39;√©l√©ments √† la liste.</p>
<ul>
<li>Impl√©mentez le clic sur le <code>FloatingActionButton</code> pour ajouter un nouvel √©l√©ment √† la liste comme pr√©c√©demment mais en Compose:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">onClick = {
    val newItem = Task(title = &#34;Item #${items.size}&#34;)
    items = items + newItem
}
</code></pre>
<ul>
<li>Lancez l&#39;app et testez l&#39;ajout d&#39;√©l√©ments: vous devriez voir la liste se mettre √† jour automatiquement mais il faut scroller jusqu&#39;en bas pour voir le nouvel √©l√©ment</li>
<li>Pour am√©liorer √ßa, utilisez le <code>LazyListState</code> pour scroller automatiquement jusqu&#39;en bas:</li>
<li>Ajoutez un <code>val listState = rememberLazyListState()</code> en haut de <code>ListScreen</code></li>
<li>Passez le <code>listState</code> √† la <code>LazyColumn</code> avec <code>state = listState</code></li>
<li>Modifiez le <code>onClick</code> du <code>FloatingActionButton</code> pour scroller jusqu&#39;en bas apr√®s avoir ajout√© l&#39;√©l√©ment avec <code>listState.animateScrollToItem(items.size - 1)</code></li>
</ul>
<aside class="warning"><p>‚ö†Ô∏è Une erreur va s&#39;afficher car la d√©finition de <code>animateScrollToItem</code> contient un mot cl√© <code>suspend</code>:</p>
<p>il sert √† signifier que cette fonction ne peut pas s&#39;ex√©cuter comme une fonction normale car elle peut potentiellement bloquer le thread courant en prenant beaucoup de temps √† se terminer</p>
<p>Afin de compiler, il faudra donc l&#39;appeler dans le contexte d&#39;un <code>CouroutineScope</code> (ou dans une autre fonction <code>suspend</code>)</p>
</aside>
<ul>
<li>Ajoutez un <code>val coroutineScope = rememberCoroutineScope()</code> en haut de <code>ListScreen</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">coroutineScope.launch {
  // suspend function
}
</code></pre>
<aside class="special"><p><strong>Remarque:</strong> C&#39;est le scope qu&#39;on va utiliser pour ce qui se passe dans l&#39;UI Compose. Dans une UI en Views classique on a <code>lifeCycleScope</code></p>
<p>En g√©n√©ral ce scope sert plut√¥t √† ce qui est visuel (ici lancer une animation est un bon exemple)</p>
<p>On utilise souvent un autre scope: <code>viewModelScope</code> qui est fourni par android dans les <code>ViewModel</code>, pour la logique plus &#34;intelligente&#34; de l&#39;app: faire des requ√™tes HTTP par exemple.</p>
</aside>
<ul>
<li>Lancez l&#39;app et testez √† nouveau l&#39;ajout d&#39;√©l√©ments: cette fois la liste devrait scroller automatiquement jusqu&#39;au nouvel √©l√©ment ajout√©</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Suppression d&#39;√©l√©ments" duration="0">
        <p>Ajoutez un bouton de suppression dans chaque √©l√©ment et faites sorte qu&#39;il fonctionne Pour avoir un item avec le texte √† gauche et le bouton tout √† droite vous pouvez utiliser une <code>Row</code> avec <code>horizontalArrangement = Arrangement.SpaceBetween</code> ou bien un <code>Spacer(modifier = Modifier.weight(1f))</code> entre les 2 √©l√©ments.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Navigation" duration="0">
        <p>On va d&#39;abord permettre de naviguer vers notre ancienne <code>MainActivity</code>:</p>
<ul>
<li>Ajoutez une fl√®che dans les <code>actions</code> de la top bar:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">IconButton(onClick = {...}) {
  Icon(
      imageVector = Icons.AutoMirrored.Filled.ArrowForward,
      contentDescription = &#34;go to classic app&#34;
  )
}
</code></pre>
<ul>
<li>Impl√©mentez le clic pour naviguer vers l&#39;ancienne <code>MainActivity</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val intent = Intent(context, MainActivity::class.java)
context.startActivity(intent)
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ On cr√©e ici un simple <strong>Intent explicite</strong> et on l&#39;utilise pour naviguer</p>
</aside>
<p>Pour r√©cup√©rer un <code>Context</code> on utilise un <code>CompositionLocal</code>:</p>
<pre><code language="language-kotlin" class="language-kotlin">val context = LocalContext.current
</code></pre>
<ul>
<li>Lancez l&#39;app et testez la navigation vers l&#39;ancienne activity</li>
</ul>
<p>Maintenant on va utiliser la biblioth√®que <code>Navigation3</code> pour g√©rer la navigation de mani√®re plus propre:</p>
<ul>
<li>renseignez vous sur <a href="https://developer.android.com/guide/navigation/navigation-3" target="_blank">la doc officielle</a></li>
<li>Ajoutez les d√©pendances n√©cessaires dans <code>app/build.gradle.kts</code>: <a href="https://developer.android.com/guide/navigation/navigation-3/get-started#project-setup" target="_blank">doc</a></li>
<li>Cr√©ez un nouveau fichier DetailScreen.kt avec une fonction <code>@Composable</code> <code>DetailScreen(task: Task)</code> qui affiche les d√©tails d&#39;une t√¢che</li>
<li>Utilisez l&#39;IDE pour extraire <code>ListScreen</code> dans un autre fichier √©galement</li>
<li>Dans <code>ComposeActivity</code>, au lieu d&#39;afficher directement <code>ListScreen</code>, cr√©ez et utilisez un composant <code>App()</code>:</li>
<li>Gardez le Scaffold dans <code>ListScreen</code> sans la topBar: d√©placez l√† dans un autre Scaffold que vous ajouterez dans <code>App()</code> pour qu&#39;elle soit commune √† tous les √©crans</li>
<li>Modifiez <code>ListScreen</code> pour qu&#39;au clic sur un √©l√©ment, on navigue vers <code>DetailNavScreen</code></li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Serializable
data object ListNavScreen : NavKey
@Serializable
data class DetailNavScreen(val task: Task) : NavKey

@Composable
fun App() {
    // on cr√©√© notre historique de navigation avec la liste comme √©cran initial
    val backStack = rememberNavBackStack(ListNavScreen)

    NavDisplay(
      backStack = backStack,
      entryProvider = entryProvider {
        entry&lt;ListNavScreen&gt; { ListScreen(onClickItem = {...}) }
        entry&lt;DetailNavScreen&gt; { key -&gt; DetailScreen(task = key.task) }
      }
    )
}
</code></pre>
<ul>
<li>Extraire un composant <code>TaskItem</code> pour la partie qui affiche chaque item et faire en sorte qu&#39;au clic sur un item, on remonte un event onClick qui permettra de naviguer vers l&#39;√©cran d√©tail:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun TaskItem(
    modifier: Modifier = Modifier,
    item: Task,
    onClick: (Task) -&gt; Unit,
    onDelete: () -&gt; Unit,
) {...}
</code></pre>
<aside class="special"><p>üßë‚Äçüè´ <strong>Modifiers</strong></p>
<p>Par convention, chaque composant doit avoir un argument <code>modifier</code> de type <code>Modifier</code> avec comme valeur par d√©faut....<code>Modifier</code> !</p>
<p><code>Modifier</code> est une interface dont le <code>companion object</code> impl√©mente... <code>Modifier</code></p>
<p>C&#39;est assez simple en v√©rit√©: √ßa permet d&#39;utilier <code>Modifier</code> comme point de d√©part et valeur par d√©faut: c&#39;est un modifier qui ne fait rien.</p>
<p>Ensuite plein de diff√©rentes impl√©mentations de <code>Modifier</code> existent et sont configur√©s de fa√ßon √† pouvoir s&#39;encha√Æner comme ceci et ajouter des comportements ou des modifications visuelles:</p>
<pre><code language="language-kotlin" class="language-kotlin">Modifier.fillMaxSize(0.5f)
    .padding(8.dp)
    .clickable { }
</code></pre>
<p>‚ö†Ô∏è l&#39;argument <code>modifier</code> de chaque Composant doit toujours √™tre utilis√© dans le composant &#34;root&#34; qui le constitue, par exemple:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun Login(modifier: Modifier = Modifier) {
    Column(
        modifier = modifier // on ins√©re le modifier √† la racine
            .padding(8.dp) // et on peut aussi ajouter des modifiers dessus
    ) {
        TextField(/* ... */)
        TextField(/* ... */)
    }
}
</code></pre>
</aside>
<ul>
<li>Dans <code>App()</code>, faites en sorte que ce clic navigue bien:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">// Pour naviguer vers l&#39;√©cran d√©tail, on l&#39;ajoute √† l&#39;historique:
backStack.add(DetailNavScreen(...))
</code></pre>
<ul>
<li>Ajoutez un bouton &#34;OK&#34; dans <code>DetailScreen</code> qui permet de revenir en arri√®re:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">// Pour revenir en arri√®re, on enl√®ve le dernier √©cran de l&#39;historique:
backStack.removeLastOrNull()
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById("arrow-back").href="/formation-android/codelabs/";
            document.getElementById("done").href="/formation-android/codelabs/";
        }, false);
    </script>

    